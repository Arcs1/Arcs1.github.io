<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Portfolio</title>

  <link rel="stylesheet" href="main.css">
</head>

<body>
  <main class="page-wrapper">
    <!-- Intro -->
    <section class="intro">
      <h1>Portfolio</h1>
      <div class="accent-line"></div>
      <p>
        This page extends my CV by offering deeper insight into projects I've worked on,
        both personal and collaborative, with a focus on design choices and technical considerations that are difficult
        to fully capture in a traditional résumé.
      </p>
      <p>
        As this is a publicly accessible page, personal identifying information is intentionally excluded.
      </p>
    </section>

    <!-- Personal Portfolio -->
    <section class="project-card collapsed">
      <div class="card-header-wrapper">
        <div class="card-header">
          <h2>Personal Portfolio (This Page)</h2>
          <div class="tags">
            <span class="tag">
              <object data="assets/html.svg"></object>
              <span>HTML</span>
            </span>
            <span class="tag">
              <object data="assets/css.svg"></object>
              <span>CSS</span>
            </span>
            <span class="tag">
              <object data="assets/javascript.svg"></object>
              <span>JavaScript</span>
            </span>
          </div>
          <div class="arrow">&#9660;</div>
        </div>
      </div>

      <div class="card-content-wrapper">
        <div class="card-content">
          <p>
            This project is an extension of my CV, created to provide deeper and more detailed insight into the projects
            I've worked on with details that are difficult to fit within the constraints of a traditional résumé.
          </p>
          <p>
            Beyond serving as a portfolio, this project was also a deliberate exercise in working with pure HTML, CSS,
            and
            JavaScript, without relying on frameworks or utility libraries. Having previously worked mostly with Vue and
            tools like Tailwind, I wanted to strengthen my understanding of core web technologies and improve my ability
            to build interfaces from first principles.
          </p>
          <p>
            The page uses a dark, centered layout to keep content readable and focused, especially on large screens, and
            is designed to grow organically as new projects are added. Throughout development, I focused on learning raw
            CSS layout, transitions, and structure, using AI and online resources as guidance rather than shortcuts,
            reviewing and adapting all solutions to fit my needs.
          </p>
          <p>
            While small in scope, this project reflects my willingness to step outside my comfort zone, learn unfamiliar
            tools, and iteratively solve problems as they arise.
          </p>
          <p>
            The source code for this project can be found <a href="https://github.com/Arcs1/Arcs1.github.io"
              target="_blank" rel="noopener noreferrer">here</a>.
          </p>
        </div>
      </div>
    </section>

    <!-- Trading Bot -->
    <section class="project-card collapsed">
      <div class="card-header-wrapper">
        <div class="card-header">
          <h2>Cryptocurrency Trading Bot</h2>
          <div class="tags">
            <span class="tag">
              <object data="assets/python.svg"></object>
              <span>Python</span>
            </span>
            <span class="tag">
              <object data="assets/ccxt.svg"></object>
              <span>CCXT</span>
            </span>
            <span class="tag">
              <object data="assets/flask.svg"></object>
              <span>Flask</span>
            </span>
            <span class="tag">
              <object data="assets/mariadb.svg"></object>
              <span>MariaDB</span>
            </span>
            <span class="tag">
              <object data="assets/vuejs.svg"></object>
              <span>Vue.js</span>
            </span>
            <span class="tag">
              <object data="assets/tailwindcss.svg"></object>
              <span>Tailwind CSS</span>
            </span>
            <span class="tag">
              <object data="assets/docker.svg"></object>
              <span>Docker</span>
            </span>
          </div>
          <div class="arrow">&#9660;</div>
        </div>
      </div>

      <div class="card-content-wrapper">
        <div class="card-content">
          <p>
            This is a long-running project developed and maintained since February 2025.
            It originated from a collaboration with my brother, who proposed the initial
            <a href="https://www.ig.com/en/trading-need-to-knows/what-is-trading" target="_blank"
              rel="noopener noreferrer">trading</a> idea while I was looking for a job.
            What began as a quick prototype evolved through multiple major iterations into a modular, extensible,
            multi-exchange trading system with a dedicated backend, database, and frontend interface.
          </p>

          <p>
            This is the project I am most proud of to date, both for its technical depth and for the way it reflects my
            growth as a developer.
          </p>

          <p>
            Throughout its development, the project went through three major versions, each addressing limitations
            of the previous one and introducing increasingly robust architectural decisions.
          </p>

          <br>

          <h3>Version 1</h3>

          <p>
            The first version was built quickly to take advantage of a short-term trading opportunity my brother noticed
            for a specific
            <a href="https://en.wikipedia.org/wiki/Ticker_symbol" target="_blank" rel="noopener noreferrer">symbol</a>
            (also called ticker) at the time.
            It was intentionally minimal and, in hindsight, extremely poorly structured.
            The entire bot relied on a single <code>while true</code> loop that polled exchange data every few seconds,
            repeatedly fetching static or otherwise unnecessary information.
          </p>

          <p>
            All logic and helper functions lived in a single file, and any configuration changes required a full restart
            of the bot.
            The application ran locally and initially supported trading only one symbol on a single
            <a href="https://en.wikipedia.org/wiki/Cryptocurrency_exchange" target="_blank"
              rel="noopener noreferrer">exchange</a>.
            As requirements grew, such as supporting multiple exchanges and multiple symbols,
            extensibility quickly became a major issue.
          </p>

          <p>
            To move fast, I duplicated the project multiple times and adapted each copy for a specific exchange or
            symbol
            set.
            While this approach worked temporarily, it clearly did not scale.
            This phase exposed the cost of poor architecture and code duplication, and it directly motivated a complete
            redesign of the system.
          </p>

          <br>

          <h3>Version 2</h3>

          <p>
            The second version focused on consolidating everything into a single, deployable application.
            It was driven by three core goals:
          </p>

          <ul>
            <li>Be deployable on a remote machine</li>
            <li>Centralize shared trading logic</li>
            <li>Provide a frontend so settings could be updated at runtime</li>
          </ul>

          <p>
            As this version was still developed under time pressure, I chose
            <a href="https://flask.palletsprojects.com/en/stable/" target="_blank" rel="noopener noreferrer">Flask</a>
            for the backend API, as I already had some familiarity with it and it allowed me to move quickly.
            The API itself was simple, but it enabled a major shift in how the bot was controlled.
          </p>

          <p>
            This version introduced several important improvements.
            For the first time, a single backend handled multiple strategies and exchanges.
            Logging was added, which was my first real experience using a proper logging system.
            It proved to be a game changer, making it significantly easier to observe runtime behavior and debug issues.
          </p>

          <p>
            I also introduced inheritance to reduce duplicated code by extracting shared logic into base classes.
            While this was a step in the right direction, those abstractions were not as scalable as they could have
            been.
            Some strategy specific logic still lived in the base classes, and as new features and strategies were added,
            code duplication gradually reappeared.
            Despite its flaws, this approach was still a substantial improvement over Version 1 and highlighted the
            importance of clean, well-defined abstractions.
          </p>

          <p>
            Another key improvement was the adoption of official exchange SDKs instead of making raw REST API calls.
            This allowed faster development and cleaner integrations.
            During this version, I also worked with WebSockets for the first time, using them to receive near real-time
            market data and order updates.
          </p>

          <p>
            The frontend was built using
            <a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue.js</a> and
            <a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">Tailwind CSS</a>
            and was intentionally designed as a command line style
            interface.
            The original plan was to control the bot via SSH commands, but this would have been inconvenient for my
            non-technical brother.
            To avoid scrapping the already implemented command handling logic and to save time, I adapted that approach
            into a web-based interface instead.
          </p>

          <img alt="Command line page" src="/assets/command_line_page.png">

          <p>
            Configuration management also evolved in this version.
            Settings were moved out of static config files into a <code>settings.py</code> module.
            To persist changes without setting up a database, I stored settings in an in-memory dictionary and
            serialized
            them to disk, relying on a
            <a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer">Docker</a>
            volume for persistence.
            In hindsight, this was unnecessary complexity and could have been handled more cleanly with a simpler format
            such as JSON, but it served its purpose at the time.
          </p>

          <p>
            Deployment was handled using Docker and
            <a href="https://caprover.com/" target="_blank" rel="noopener noreferrer">CapRover</a>,
            running on a private node owned by a friend.
          </p>

          <br>

          <h3>Version 3</h3>

          <p>
            The third version was a deliberate attempt to do things properly.
            After the lessons learned from earlier iterations, this version focused on long-term maintainability
            and scalability rather than speed. The main goals were:
          </p>

          <ul>
            <li>Maximum extensibility (new strategies and new exchanges)</li>
            <li>Clear separation of responsibilities</li>
            <li>Reliable persistence and configuration management</li>
            <li>A more robust and well-structured API</li>
          </ul>

          <p>
            After researching available solutions, I adopted the
            <a href="https://github.com/ccxt/ccxt" target="_blank" rel="noopener noreferrer">CCXT</a>
            library to standardize interaction with multiple cryptocurrency exchanges.
            While CCXT solved many integration problems out of the box, I identified performance limitations
            in some of its standardized REST methods.
            To address this, I implemented custom wrappers around exchange-specific endpoints while still
            leveraging CCXT for consistency, WebSocket support, and built-in features such as rate limiting.
          </p>

          <p>
            This version introduced significant architectural changes.
            A single base exchange class now defines common behavior, with exchange specific implementations
            delegated to child classes.
            Shared concerns are explicitly separated through dedicated managers, such as a WebSocket manager
            responsible for connection lifecycle and subscriptions, and a strategy manager responsible for
            starting, updating, and stopping strategies.
          </p>

          <p>
            Persistence was also completely redesigned.
            Configuration and runtime settings moved out of local files and into a
            <a href="https://mariadb.org/" target="_blank" rel="noopener noreferrer">MariaDB</a> database.
            This allowed strategy and symbol level settings to be managed in a structured and scalable way,
            making it significantly easier to extend the system with new parameters, features, and metadata.
            An in-memory cache was introduced to reduce database load while keeping the system responsive.
          </p>

          <p>
            As the API surface expanded, it was hardened accordingly.
            Endpoints were reorganized using <a href="https://flask.palletsprojects.com/en/stable/blueprints/"
              target="_blank" rel="noopener noreferrer">Flask Blueprints</a> for better modularity, and request
            validation
            was enforced using <a href="https://marshmallow.readthedocs.io/en/latest/" target="_blank"
              rel="noopener noreferrer">Marshmallow</a> schemas to ensure data consistency and reliability across the
            system.
          </p>

          <p>
            The frontend evolved from a single page command interface into a multi-page platform.
            It now provides an overview of all strategy instances and their ON/OFF state, as well as detailed
            configuration pages for each strategy.
            From the UI, it is possible to add, update, enable, disable, or remove individual symbols at runtime,
            along with modifying strategy level settings and controlling execution state to some extent.
          </p>

          <p>
            To keep interactions fluid and avoid excessive routing complexity, I adopted a modal-based UI
            approach for actions such as adding symbols and confirmation flows.
            This design choice improves usability and allows UI components to be reused across future pages,
            like dashboards or aggregated views.
          </p>
        </div>
      </div>
    </section>

    <!-- Embalagem do Futuro -->
    <section class="project-card collapsed">
      <div class="card-header-wrapper">
        <div class="card-header">
          <h2>Embalagem do Futuro</h2>
          <div class="tags">
            <span class="tag">
              <object data="assets/flask.svg"></object>
              <span>Flask</span>
            </span>
            <span class="tag">
              <object data="assets/pandas.svg"></object>
              <span>Pandas</span>
            </span>
            <span class="tag">
              <object data="assets/vuejs.svg"></object>
              <span>Vue.js</span>
            </span>
            <span class="tag">
              <object data="assets/tailwindcss.svg"></object>
              <span>Tailwind CSS</span>
            </span>
          </div>
          <div class="arrow">&#9660;</div>
        </div>
      </div>

      <div class="card-content-wrapper">
        <div class="card-content">
          <p>
            <em>Embalagem do Futuro</em> was my final project while completing my degree in Informatics Engineering
            and was developed under the scope of a PRR-funded initiative in collaboration with the company
            <a href="https://www.prozis.com/" target="_blank" rel="noopener noreferrer">Prozis</a>.
            The goal of the project was to help identify and diagnose issues occurring during product transportation,
            such as temperature-sensitive goods arriving damaged or unsuitable for sale, by collecting and analyzing
            sensor data throughout the logistics process.
          </p>

          <p>
            When I joined the project, it was already ongoing as a continuation of work started by students from the
            previous academic year.
            The software team consisted of four members in total: two Master's students who were already part of the
            project and primarily focused on process mining, and myself and another Bachelor's student, who joined
            later and took responsibility for data processing and frontend development.
            In parallel, a separate team from another course was responsible for the hardware side of the project,
            specifically the development of sensors intended to be embedded in transport packages.
          </p>

          <p>
            Throughout the project, we worked directly with Prozis stakeholders, holding monthly validation meetings
            to review progress and align on requirements, as well as weekly meetings with the product owner,
            one of our teachers, to validate implementations, discuss progress, and address technical or
            organizational challenges.
            Each member of the software team was supported by a research grant, reinforcing the project's
            professional and real-world context.
          </p>

          <p>
            During my involvement, the hardware components were still under development, so we relied on simulated
            datasets provided as CSV files.
            My responsibilities focused on data handling and frontend presentation.
            On the backend, I implemented several API endpoints using
            <a href="https://flask.palletsprojects.com/en/stable/" target="_blank" rel="noopener noreferrer">Flask</a>,
            extracting and transforming data with
            <a href="https://pandas.pydata.org/" target="_blank" rel="noopener noreferrer">pandas</a>
            to meet the requirements of different visualizations.
          </p>

          <p>
            I also implemented a basic authentication system, handling both backend and frontend login logic.
            Although the platform was originally intended to support multiple user roles, these requirements were
            never finalized by the stakeholders during my time on the project, so role-based access control was not
            implemented.
          </p>

          <p>
            The frontend was built with
            <a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue.js</a>
            and styled using
            <a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">Tailwind CSS</a>.
            I worked primarily on the dashboard and statistics pages.
            The dashboard presented a large table where each column represented a month of the year and each row
            corresponded to a specific indicator.
            Clicking a table cell opened a modal with a chart and local filters, displaying data specific to the
            selected indicator and month.
          </p>

          <p>
            A key usability feature of the platform was the use of global filters that applied across all pages,
            complemented by local filters specific to individual charts and the dashboard.
            Designing these filters posed UX challenges, particularly due to limited screen real estate in the
            navigation bar.
            This was addressed by introducing hierarchical filter menus, keeping the most frequently used options
            immediately accessible while grouping less common filters into submenus.
          </p>

          <p>
            Another technical challenge was performance, particularly when loading the statistics page.
            With many charts rendered simultaneously and significant client-side data processing required,
            the UI suffered from noticeable slowdowns.
            I addressed this problem by introducing Web Workers to offload heavy data processing from the main thread,
            resulting in a much smoother user experience.
          </p>

          <p>
            While the project continued after my participation ended, our team consistently delivered all requested
            features on time.
            The dashboard and filtering system were particularly well received by the stakeholders, even though
            iterative feedback and adjustments were a constant part of the process.
            This project was especially valuable for the experience it provided in working within a real-world,
            industry-driven environment, where technical decisions and implementations were regularly reviewed and
            evaluated by non-academic stakeholders.
          </p>
        </div>
      </div>
    </section>

    <script src="main.js"></script>
  </main>
</body>

</html>
